<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monte Carlo Feature Explorer - Direct LanceDB</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        h1 {
            color: #4fc3f7;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .status {
            font-size: 14px;
            padding: 5px 10px;
            border-radius: 4px;
            background: #2a2a2a;
        }
        
        .status.connected {
            background: #4caf50;
            color: white;
        }
        
        .status.error {
            background: #f44336;
            color: white;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #4fc3f7;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #888;
            font-size: 14px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .chart-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .chart-title {
            font-size: 16px;
            color: #4fc3f7;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .chart {
            height: 350px;
            width: 100%;
            position: relative;
            flex: 1;
            min-height: 0;
        }
        
        .chart canvas {
            display: block;
            height: 100% !important;
            width: 100% !important;
        }
        
        .combinations-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .combination-row {
            padding: 15px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .combination-row:hover {
            background: #333;
        }
        
        .combination-row.selected {
            background: #0d47a1;
        }
        
        .combination-header {
            font-weight: 600;
            color: #4fc3f7;
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        .combination-stats {
            font-size: 13px;
            color: #bbb;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }
        
        .reliability-bar {
            width: 80px;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            display: inline-block;
            margin-left: 5px;
            vertical-align: middle;
        }
        
        .reliability-fill {
            height: 100%;
            background: linear-gradient(90deg, #f44336, #ff9800, #4caf50);
            transition: width 0.3s ease;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .error {
            color: #f44336;
            text-align: center;
            padding: 40px;
        }
        
        button {
            background: #4fc3f7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #29b6f6;
        }
        
        .controls {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group label {
            font-size: 12px;
            color: #888;
        }
        
        .control-group select, .control-group input {
            background: #333;
            border: 1px solid #555;
            color: #e0e0e0;
            padding: 5px 8px;
            border-radius: 4px;
            min-width: 100px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            Monte Carlo Feature Explorer - Direct LanceDB
            <div>
                <button onclick="exportCSV()">Export CSV</button>
                <span id="status" class="status">Connecting...</span>
            </div>
        </h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Instrument</label>
                <select id="instrumentFilter">
                    <option value="">All Instruments</option>
                </select>
            </div>
            <div class="control-group">
                <label>Direction</label>
                <select id="directionFilter">
                    <option value="">All Directions</option>
                    <option value="long">Long</option>
                    <option value="short">Short</option>
                </select>
            </div>
            <div class="control-group">
                <label>Min Trades</label>
                <input type="number" id="minTrades" value="10" min="5" max="500">
            </div>
            <div class="control-group">
                <label>Simulations</label>
                <input type="number" id="simulations" value="1000" min="100" max="5000" step="100">
            </div>
            <button onclick="refreshData()">Refresh Data</button>
        </div>
        
        <div class="stats-grid" id="statsGrid">
            <div class="stat-card">
                <div class="stat-value" id="totalVectors">-</div>
                <div class="stat-label">Total Vectors</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="featureCount">-</div>
                <div class="stat-label">Features per Vector</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="winRate">-</div>
                <div class="stat-label">Win Rate</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgPnL">-</div>
                <div class="stat-label">Average PnL</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalPnL">-</div>
                <div class="stat-label">Total PnL</div>
            </div>
        </div>
        
        <div class="grid">
            <div class="chart-container">
                <div class="chart-title">Feature Combinations (Click to analyze)</div>
                <div class="combinations-list" id="combinationsList">
                    <div class="loading">Loading feature combinations...</div>
                </div>
            </div>
            
            <div class="chart-container">
                <div class="chart-title">Monte Carlo PnL Distribution</div>
                <div class="chart">
                    <canvas id="monteCarloPnL"></canvas>
                </div>
            </div>
        </div>
        
        <div class="grid">
            <div class="chart-container">
                <div class="chart-title">Confidence vs PnL Scatter</div>
                <div class="chart">
                    <canvas id="confidenceScatter"></canvas>
                </div>
            </div>
            
            <div class="chart-container">
                <div class="chart-title">Feature Reliability Heatmap</div>
                <div class="chart">
                    <canvas id="reliabilityHeatmap"></canvas>
                </div>
            </div>
        </div>
        
        <div class="chart-container full-width">
            <div class="chart-title">Profit Trajectory Simulations</div>
            <div class="chart">
                <canvas id="trajectoryChart"></canvas>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let allVectors = [];
        let featureCombinations = [];
        let selectedCombination = null;
        let charts = {};
        const API_BASE = 'http://localhost:3018';
        
        class DirectMonteCarloAnalyzer {
            constructor() {
                this.loadData();
            }
            
            async loadData() {
                try {
                    this.updateStatus('Connecting to Direct API...', 'connecting');
                    
                    // Test connection first
                    const healthResponse = await fetch(`${API_BASE}/health`);
                    if (!healthResponse.ok) {
                        throw new Error('Direct API not available');
                    }
                    
                    this.updateStatus('Loading vectors...', 'connecting');
                    
                    // Load vectors and stats
                    const [vectorsResponse, statsResponse] = await Promise.all([
                        fetch(`${API_BASE}/api/vectors?limit=5000`),
                        fetch(`${API_BASE}/api/stats`)
                    ]);
                    
                    const vectorsData = await vectorsResponse.json();
                    const statsData = await statsResponse.json();
                    
                    if (!vectorsData.success || !statsData.success) {
                        throw new Error('Failed to load data from API');
                    }
                    
                    allVectors = vectorsData.vectors || [];
                    
                    console.log('Loaded data:', {
                        vectors: allVectors.length,
                        stats: statsData.stats,
                        sample: allVectors[0]
                    });
                    
                    this.updateStats(statsData.stats);
                    this.populateFilters();
                    this.analyzeFeatureCombinations();
                    
                    this.updateStatus('Connected ✓', 'connected');
                    
                } catch (error) {
                    console.error('Failed to load data:', error);
                    this.updateStatus('Connection Error ✗', 'error');
                    document.getElementById('combinationsList').innerHTML = 
                        `<div class="error">Failed to connect to Direct API: ${error.message}<br>
                        <small>Make sure to start the direct API: node direct-api.js</small></div>`;
                }
            }
            
            updateStatus(message, type) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
            }
            
            updateStats(stats) {
                document.getElementById('totalVectors').textContent = stats.totalVectors.toLocaleString();
                document.getElementById('featureCount').textContent = stats.featureCount;
                document.getElementById('winRate').textContent = (stats.winRate * 100).toFixed(1) + '%';
                document.getElementById('avgPnL').textContent = '$' + stats.avgPnL.toFixed(2);
                document.getElementById('totalPnL').textContent = '$' + stats.totalPnL.toFixed(2);
            }
            
            populateFilters() {
                const instruments = [...new Set(allVectors.map(v => v.instrument).filter(Boolean))];
                const instrumentSelect = document.getElementById('instrumentFilter');
                
                instruments.forEach(instrument => {
                    const option = document.createElement('option');
                    option.value = instrument;
                    option.textContent = instrument;
                    instrumentSelect.appendChild(option);
                });
            }
            
            analyzeFeatureCombinations() {
                if (allVectors.length === 0) {
                    document.getElementById('combinationsList').innerHTML = 
                        '<div class="error">No vectors available for analysis</div>';
                    return;
                }
                
                // Extract feature names from first vector with features
                const featureNames = this.extractFeatureNames();
                console.log('Feature names extracted:', featureNames.length);
                
                if (featureNames.length < 2) {
                    document.getElementById('combinationsList').innerHTML = 
                        '<div class="error">Insufficient features for combination analysis</div>';
                    return;
                }
                
                // Generate top feature pairs
                featureCombinations = this.generateFeaturePairs(featureNames.slice(0, 15)); // Top 15 for performance
                
                console.log('Generated combinations:', featureCombinations.length);
                
                this.renderCombinations();
            }
            
            extractFeatureNames() {
                for (const vector of allVectors) {
                    if (vector.featuresJson) {
                        try {
                            const features = JSON.parse(vector.featuresJson);
                            const names = Object.keys(features).filter(name => 
                                !['timestamp', 'id', 'entrySignalId'].includes(name)
                            );
                            if (names.length > 0) {
                                return names.sort();
                            }
                        } catch (e) {
                            continue;
                        }
                    }
                }
                return [];
            }
            
            generateFeaturePairs(featureNames) {
                const pairs = [];
                const maxPairs = 20; // Limit for performance
                
                for (let i = 0; i < featureNames.length && pairs.length < maxPairs; i++) {
                    for (let j = i + 1; j < featureNames.length && pairs.length < maxPairs; j++) {
                        const pair = [featureNames[i], featureNames[j]];
                        const analysis = this.analyzePair(pair);
                        
                        if (analysis.trades >= parseInt(document.getElementById('minTrades').value)) {
                            pairs.push({
                                features: pair,
                                ...analysis,
                                reliability: this.calculateReliability(analysis)
                            });
                        }
                    }
                }
                
                return pairs.sort((a, b) => b.reliability - a.reliability);
            }
            
            analyzePair(featurePair) {
                const [feature1, feature2] = featurePair;
                
                // Analyze vectors based on feature value ranges for this specific pair
                const vectorsWithFeatures = allVectors.filter(v => {
                    if (!v.featuresJson) return false;
                    try {
                        const features = JSON.parse(v.featuresJson);
                        // Must have both features
                        return features.hasOwnProperty(feature1) && 
                               features.hasOwnProperty(feature2) &&
                               features[feature1] !== null &&
                               features[feature2] !== null;
                    } catch (e) {
                        return false;
                    }
                });
                
                if (vectorsWithFeatures.length === 0) {
                    return {
                        trades: 0,
                        pnlValues: [],
                        meanPnL: 0,
                        stdDev: 0,
                        winRate: 0,
                        minPnL: 0,
                        maxPnL: 0
                    };
                }
                
                // Get feature ranges
                const feature1Values = vectorsWithFeatures.map(v => {
                    const features = JSON.parse(v.featuresJson);
                    return parseFloat(features[feature1]);
                });
                const feature2Values = vectorsWithFeatures.map(v => {
                    const features = JSON.parse(v.featuresJson);
                    return parseFloat(features[feature2]);
                });
                
                // Calculate quartiles for each feature
                const f1Sorted = [...feature1Values].sort((a, b) => a - b);
                const f2Sorted = [...feature2Values].sort((a, b) => a - b);
                const q1Index = Math.floor(f1Sorted.length * 0.25);
                const q3Index = Math.floor(f1Sorted.length * 0.75);
                
                const f1Q1 = f1Sorted[q1Index];
                const f1Q3 = f1Sorted[q3Index];
                const f2Q1 = f2Sorted[q1Index];
                const f2Q3 = f2Sorted[q3Index];
                
                // Analyze vectors in different quadrants
                const quadrantAnalysis = {
                    lowLow: [], // Both features in lower quartile
                    lowHigh: [], // Feature1 low, Feature2 high
                    highLow: [], // Feature1 high, Feature2 low
                    highHigh: [], // Both features in upper quartile
                    middle: [] // Everything else
                };
                
                vectorsWithFeatures.forEach(v => {
                    const features = JSON.parse(v.featuresJson);
                    const f1Val = parseFloat(features[feature1]);
                    const f2Val = parseFloat(features[feature2]);
                    const pnl = parseFloat(v.pnl || v.pnlDollars || 0);
                    
                    if (isNaN(pnl) || pnl === 0) return;
                    
                    if (f1Val <= f1Q1 && f2Val <= f2Q1) {
                        quadrantAnalysis.lowLow.push(pnl);
                    } else if (f1Val <= f1Q1 && f2Val >= f2Q3) {
                        quadrantAnalysis.lowHigh.push(pnl);
                    } else if (f1Val >= f1Q3 && f2Val <= f2Q1) {
                        quadrantAnalysis.highLow.push(pnl);
                    } else if (f1Val >= f1Q3 && f2Val >= f2Q3) {
                        quadrantAnalysis.highHigh.push(pnl);
                    } else {
                        quadrantAnalysis.middle.push(pnl);
                    }
                });
                
                // Find the most reliable quadrant (best win rate + reasonable sample size)
                let bestQuadrant = null;
                let bestMetrics = { winRate: 0, avgPnL: 0, trades: 0 };
                
                Object.entries(quadrantAnalysis).forEach(([quadrant, pnlValues]) => {
                    if (pnlValues.length >= 10) { // Minimum sample size
                        const wins = pnlValues.filter(p => p > 0).length;
                        const winRate = wins / pnlValues.length;
                        const avgPnL = this.mean(pnlValues);
                        
                        // Score based on win rate and average PnL
                        const score = winRate * 0.7 + (avgPnL > 0 ? 0.3 : 0);
                        
                        if (score > bestMetrics.winRate * 0.7 + (bestMetrics.avgPnL > 0 ? 0.3 : 0)) {
                            bestQuadrant = quadrant;
                            bestMetrics = {
                                winRate: winRate,
                                avgPnL: avgPnL,
                                trades: pnlValues.length
                            };
                        }
                    }
                });
                
                // Use the best quadrant's data, or all data if no clear winner
                const selectedPnLs = bestQuadrant ? 
                    quadrantAnalysis[bestQuadrant] : 
                    Object.values(quadrantAnalysis).flat();
                
                const wins = selectedPnLs.filter(p => p > 0).length;
                
                return {
                    trades: selectedPnLs.length,
                    pnlValues: selectedPnLs,
                    meanPnL: this.mean(selectedPnLs),
                    stdDev: this.standardDeviation(selectedPnLs),
                    winRate: selectedPnLs.length > 0 ? wins / selectedPnLs.length : 0,
                    minPnL: selectedPnLs.length > 0 ? Math.min(...selectedPnLs) : 0,
                    maxPnL: selectedPnLs.length > 0 ? Math.max(...selectedPnLs) : 0,
                    bestQuadrant: bestQuadrant,
                    quadrantBreakdown: Object.entries(quadrantAnalysis).map(([q, pnls]) => ({
                        quadrant: q,
                        trades: pnls.length,
                        winRate: pnls.length > 0 ? pnls.filter(p => p > 0).length / pnls.length : 0
                    }))
                };
            }
            
            calculateReliability(analysis) {
                if (analysis.trades < 5) return 0;
                
                const consistencyScore = 1 / (1 + Math.abs(analysis.stdDev) / 20);
                const sampleScore = Math.min(1, analysis.trades / 100);
                const profitabilityScore = Math.max(0, analysis.winRate);
                
                return (consistencyScore * 0.4 + sampleScore * 0.3 + profitabilityScore * 0.3);
            }
            
            renderCombinations() {
                const container = document.getElementById('combinationsList');
                
                if (featureCombinations.length === 0) {
                    container.innerHTML = '<div class="error">No feature combinations found</div>';
                    return;
                }
                
                const html = featureCombinations.map((combo, index) => `
                    <div class="combination-row" data-index="${index}">
                        <div class="combination-header">
                            ${combo.features.join(' + ')}
                            ${combo.bestQuadrant ? `<span style="color: #888; font-size: 12px; margin-left: 10px;">(Best: ${combo.bestQuadrant})</span>` : ''}
                        </div>
                        <div class="combination-stats">
                            <span>Trades: ${combo.trades}</span>
                            <span>Win Rate: ${(combo.winRate * 100).toFixed(1)}%</span>
                            <span>Avg PnL: $${combo.meanPnL.toFixed(2)}</span>
                            <span>Std Dev: $${combo.stdDev.toFixed(1)}</span>
                            <span>Reliability: ${(combo.reliability * 100).toFixed(0)}%
                                <span class="reliability-bar">
                                    <span class="reliability-fill" style="width: ${combo.reliability * 100}%"></span>
                                </span>
                            </span>
                        </div>
                    </div>
                `).join('');
                
                container.innerHTML = html;
                
                // Add click handlers
                container.querySelectorAll('.combination-row').forEach((row, index) => {
                    row.addEventListener('click', () => this.selectCombination(index));
                });
                
                // Auto-select first combination
                if (featureCombinations.length > 0) {
                    this.selectCombination(0);
                }
            }
            
            selectCombination(index) {
                // Update UI selection
                document.querySelectorAll('.combination-row').forEach(row => 
                    row.classList.remove('selected'));
                document.querySelector(`[data-index="${index}"]`).classList.add('selected');
                
                selectedCombination = featureCombinations[index];
                this.runMonteCarloAnalysis(selectedCombination);
            }
            
            runMonteCarloAnalysis(combination) {
                const simulations = parseInt(document.getElementById('simulations').value);
                console.log(`Running ${simulations} Monte Carlo simulations for:`, combination.features);
                
                // Generate Monte Carlo results
                const mcResults = this.generateMonteCarloResults(combination, simulations);
                
                // Update all charts
                this.updatePnLDistribution(mcResults, combination);
                this.updateConfidenceScatter(mcResults);
                this.updateReliabilityHeatmap();
                this.updateTrajectoryChart(combination);
            }
            
            generateMonteCarloResults(combination, simulations) {
                const results = [];
                
                // Extract actual historical data for this combination
                const historicalData = combination.pnlValues || [];
                const hasGoodData = historicalData.length > 20;
                
                for (let i = 0; i < simulations; i++) {
                    // Generate different confidence levels
                    const confidenceRaw = Math.random();
                    
                    // Transform to create more realistic confidence distribution
                    // Most predictions have moderate confidence (0.4-0.7)
                    const confidence = 0.3 + (confidenceRaw * 0.6) + (this.gaussianRandom() * 0.1);
                    const clampedConfidence = Math.max(0.1, Math.min(0.95, confidence));
                    
                    // Higher confidence should mean:
                    // 1. Predictions closer to profitable historical patterns
                    // 2. Less variance in outcomes
                    // 3. Better feature alignment
                    
                    let predictedPnL;
                    
                    if (hasGoodData && clampedConfidence > 0.7) {
                        // High confidence: sample from winning trades with small noise
                        const winningTrades = historicalData.filter(p => p > 0);
                        if (winningTrades.length > 0) {
                            const basePnL = winningTrades[Math.floor(Math.random() * winningTrades.length)];
                            const noise = this.gaussianRandom() * (combination.stdDev * 0.3); // Less noise
                            predictedPnL = basePnL + noise;
                        } else {
                            // No winning trades, use mean with tight bounds
                            predictedPnL = combination.meanPnL + (this.gaussianRandom() * combination.stdDev * 0.5);
                        }
                    } else if (clampedConfidence < 0.4) {
                        // Low confidence: wider distribution, more extreme outcomes possible
                        const extremeMultiplier = 1.5 + Math.random();
                        predictedPnL = combination.meanPnL + (this.gaussianRandom() * combination.stdDev * extremeMultiplier);
                        
                        // Low confidence can hit stop losses more often
                        if (Math.random() < 0.3) {
                            predictedPnL = -30 - (Math.random() * 20); // Stop loss range
                        }
                    } else {
                        // Medium confidence: normal distribution around mean
                        predictedPnL = combination.meanPnL + (this.gaussianRandom() * combination.stdDev);
                    }
                    
                    // Add feature correlation effect
                    // When features are well-aligned (high confidence), outcomes are more predictable
                    if (clampedConfidence > 0.8 && combination.bestQuadrant) {
                        // Very high confidence in optimal quadrant
                        const quadrantMultiplier = combination.bestQuadrant.includes('high') ? 1.2 : 0.8;
                        predictedPnL *= quadrantMultiplier;
                    }
                    
                    results.push({
                        pnl: predictedPnL,
                        confidence: clampedConfidence,
                        reliability: combination.reliability,
                        quadrant: combination.bestQuadrant || 'unknown'
                    });
                }
                
                return results;
            }
            
            updatePnLDistribution(mcResults, combination) {
                const ctx = document.getElementById('monteCarloPnL').getContext('2d');
                
                // Create histogram
                const pnlValues = mcResults.map(r => r.pnl);
                const min = Math.min(...pnlValues);
                const max = Math.max(...pnlValues);
                const binCount = 25;
                const binSize = (max - min) / binCount;
                
                const bins = Array.from({length: binCount}, (_, i) => {
                    const binStart = min + i * binSize;
                    const binEnd = min + (i + 1) * binSize;
                    const count = pnlValues.filter(v => v >= binStart && v < binEnd).length;
                    return {
                        x: binStart + binSize / 2,
                        count: count
                    };
                });
                
                this.updateChart('monteCarloPnL', {
                    type: 'bar',
                    data: {
                        labels: bins.map(b => `$${b.x.toFixed(0)}`),
                        datasets: [{
                            label: `${combination.features.join(' + ')} (${mcResults.length} simulations)`,
                            data: bins.map(b => b.count),
                            backgroundColor: bins.map(b => b.x >= 0 ? 'rgba(76, 175, 80, 0.7)' : 'rgba(244, 67, 54, 0.7)'),
                            borderColor: bins.map(b => b.x >= 0 ? '#4caf50' : '#f44336'),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        ...this.getChartOptions('PnL Distribution'),
                        maintainAspectRatio: false,
                        responsive: true,
                        scales: {
                            x: {
                                ticks: { 
                                    color: '#888',
                                    maxRotation: 45,
                                    minRotation: 0
                                },
                                grid: { color: '#333' }
                            },
                            y: {
                                ticks: { color: '#888' },
                                grid: { color: '#333' },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
            
            updateConfidenceScatter(mcResults) {
                const ctx = document.getElementById('confidenceScatter').getContext('2d');
                
                // Calculate total PnL for the simulation
                const totalPnL = mcResults.reduce((sum, r) => sum + r.pnl, 0);
                
                // Separate positive and negative results
                const positiveResults = mcResults.filter(r => r.pnl >= 0);
                const negativeResults = mcResults.filter(r => r.pnl < 0);
                
                this.updateChart('confidenceScatter', {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: `Profits (${positiveResults.length})`,
                                data: positiveResults.map(r => ({
                                    x: r.confidence,
                                    y: r.pnl
                                })),
                                backgroundColor: 'rgba(76, 175, 80, 0.6)',
                                borderColor: 'rgba(76, 175, 80, 0.8)',
                                pointRadius: 3,
                                pointHoverRadius: 5
                            },
                            {
                                label: `Losses (${negativeResults.length})`,
                                data: negativeResults.map(r => ({
                                    x: r.confidence,
                                    y: r.pnl
                                })),
                                backgroundColor: 'rgba(244, 67, 54, 0.6)',
                                borderColor: 'rgba(244, 67, 54, 0.8)',
                                pointRadius: 3,
                                pointHoverRadius: 5
                            }
                        ]
                    },
                    options: {
                        ...this.getChartOptions('Confidence vs PnL'),
                        scales: {
                            x: {
                                title: { display: true, text: 'Confidence Score', color: '#888' },
                                ticks: { color: '#888' },
                                grid: { color: '#333' }
                            },
                            y: {
                                title: { display: true, text: 'Predicted PnL ($)', color: '#888' },
                                ticks: { color: '#888' },
                                grid: { color: '#333' }
                            }
                        }
                    }
                });
            }
            
            updateReliabilityHeatmap() {
                const ctx = document.getElementById('reliabilityHeatmap').getContext('2d');
                
                // Create more interesting data - show win rate vs avg PnL for top combinations
                const topCombos = featureCombinations.slice(0, 10);
                
                this.updateChart('reliabilityHeatmap', {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Feature Combinations',
                            data: topCombos.map(c => ({
                                x: c.winRate * 100,
                                y: c.meanPnL,
                                r: Math.sqrt(c.trades) * 2, // Bubble size based on sample size
                                label: c.features.join(' + ')
                            })),
                            backgroundColor: topCombos.map(c => {
                                // Color based on reliability
                                const alpha = 0.6 + (c.reliability * 0.4);
                                if (c.reliability > 0.7) return `rgba(76, 175, 80, ${alpha})`;
                                if (c.reliability > 0.5) return `rgba(255, 152, 0, ${alpha})`;
                                return `rgba(244, 67, 54, ${alpha})`;
                            }),
                            borderColor: topCombos.map(c => {
                                if (c.reliability > 0.7) return '#4caf50';
                                if (c.reliability > 0.5) return '#ff9800';
                                return '#f44336';
                            }),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        ...this.getChartOptions('Win Rate vs Avg PnL'),
                        scales: {
                            x: {
                                title: { display: true, text: 'Win Rate %', color: '#888' },
                                ticks: { color: '#888' },
                                grid: { color: '#333' },
                                min: 0,
                                max: 100
                            },
                            y: {
                                title: { display: true, text: 'Average PnL ($)', color: '#888' },
                                ticks: { color: '#888' },
                                grid: { color: '#333' }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const point = context.raw;
                                        return [
                                            point.label,
                                            `Win Rate: ${point.x.toFixed(1)}%`,
                                            `Avg PnL: $${point.y.toFixed(2)}`,
                                            `Sample Size: ${Math.pow(point.r / 2, 2).toFixed(0)}`
                                        ];
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            updateTrajectoryChart(combination) {
                const ctx = document.getElementById('trajectoryChart').getContext('2d');
                
                // Generate sample trajectories
                const trajectories = [];
                const numTrajectories = 10;
                const numBars = 20;
                
                for (let t = 0; t < numTrajectories; t++) {
                    const trajectory = [0]; // Start at 0
                    const finalPnL = combination.meanPnL + this.gaussianRandom() * combination.stdDev;
                    
                    for (let bar = 1; bar <= numBars; bar++) {
                        const progress = bar / numBars;
                        const targetValue = finalPnL * progress;
                        const noise = this.gaussianRandom() * combination.stdDev * 0.2;
                        trajectory.push(targetValue + noise);
                    }
                    
                    trajectories.push(trajectory);
                }
                
                const datasets = trajectories.map((traj, i) => ({
                    label: i === 0 ? 'Sample Trajectories' : '',
                    data: traj.map((val, bar) => ({ x: bar, y: val })),
                    borderColor: `rgba(79, 195, 247, ${0.3 + (i * 0.05)})`,
                    backgroundColor: 'transparent',
                    tension: 0.4,
                    pointRadius: 0,
                    showLine: true,
                    borderWidth: 2
                }));
                
                this.updateChart('trajectoryChart', {
                    type: 'line',
                    data: { datasets },
                    options: {
                        ...this.getChartOptions(`Profit Trajectories: ${combination.features.join(' + ')}`),
                        scales: {
                            x: {
                                title: { display: true, text: 'Time (bars)', color: '#888' },
                                ticks: { color: '#888' },
                                grid: { color: '#333' }
                            },
                            y: {
                                title: { display: true, text: 'Cumulative PnL ($)', color: '#888' },
                                ticks: { color: '#888' },
                                grid: { color: '#333' }
                            }
                        }
                    }
                });
            }
            
            updateChart(canvasId, config) {
                if (charts[canvasId]) {
                    charts[canvasId].destroy();
                }
                
                const ctx = document.getElementById(canvasId).getContext('2d');
                charts[canvasId] = new Chart(ctx, config);
            }
            
            getChartOptions(title = '') {
                return {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#e0e0e0' }
                        },
                        title: {
                            display: !!title,
                            text: title,
                            color: '#4fc3f7'
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#888' },
                            grid: { color: '#333' }
                        },
                        y: {
                            ticks: { color: '#888' },
                            grid: { color: '#333' }
                        }
                    }
                };
            }
            
            // Utility functions
            mean(arr) {
                return arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
            }
            
            standardDeviation(arr) {
                if (arr.length === 0) return 0;
                const mean = this.mean(arr);
                const squaredDiffs = arr.map(val => Math.pow(val - mean, 2));
                return Math.sqrt(this.mean(squaredDiffs));
            }
            
            gaussianRandom() {
                let u = 0, v = 0;
                while(u === 0) u = Math.random();
                while(v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            }
        }
        
        // Global functions
        function refreshData() {
            new DirectMonteCarloAnalyzer();
        }
        
        async function exportCSV() {
            try {
                window.open(`${API_BASE}/api/export/csv`, '_blank');
            } catch (error) {
                alert('Export failed: ' + error.message);
            }
        }
        
        // Initialize
        new DirectMonteCarloAnalyzer();
    </script>
</body>
</html>