#!/usr/bin/env node

/**
 * Wipe All But One Record from Agentic Memory Storage
 * 
 * This script removes all but one record from the LanceDB storage matrix,
 * keeping the system operational while resetting the dataset.
 */

const lancedb = require('vectordb');
const path = require('path');

class StorageWiper {
  constructor() {
    this.db = null;
    this.table = null;
    this.dbPath = process.env.LANCEDB_PATH || './data/vectors';
    this.tableName = 'feature_vectors';
  }

  async initialize() {
    try {
      console.log('üîó Connecting to LanceDB...');
      
      // Connect to LanceDB
      this.db = await lancedb.connect(this.dbPath);
      
      // Check if table exists
      const tables = await this.db.tableNames();
      
      if (!tables.includes(this.tableName)) {
        console.log('‚ùå No storage table found - database is empty');
        return false;
      }
      
      this.table = await this.db.openTable(this.tableName);
      console.log('‚úÖ Connected to storage table');
      return true;
      
    } catch (error) {
      console.error('‚ùå Failed to connect to storage:', error.message);
      throw error;
    }
  }

  async getStats() {
    try {
      const allVectors = await this.table.filter('id IS NOT NULL').limit(1000000).execute();
      return {
        totalCount: allVectors.length,
        vectors: allVectors
      };
    } catch (error) {
      console.error('‚ùå Failed to get stats:', error.message);
      throw error;
    }
  }

  async wipeAllButOne() {
    try {
      console.log('üìä Analyzing current storage...');
      
      const stats = await this.getStats();
      
      if (stats.totalCount === 0) {
        console.log('üìù Storage is already empty - nothing to wipe');
        return { success: true, message: 'Already empty' };
      }

      if (stats.totalCount === 1) {
        console.log('üìù Storage already has only one record - nothing to wipe');
        return { success: true, message: 'Already minimal' };
      }

      console.log(`üìà Found ${stats.totalCount} records in storage`);
      
      // Show record details
      console.log('\nüìã CURRENT RECORDS:');
      console.log('‚îÄ'.repeat(80));
      console.log('ID'.padEnd(25) + 'Instrument'.padEnd(12) + 'Entry Type'.padEnd(15) + 'PnL'.padEnd(10) + 'Date');
      console.log('‚îÄ'.repeat(80));
      
      stats.vectors.forEach((vector, index) => {
        console.log(
          `${index + 1}. ${vector.id.substring(0, 24)}`.padEnd(25) +
          (vector.instrument || 'N/A').padEnd(12) +
          (vector.entryType || 'N/A').padEnd(15) +
          `$${(vector.pnl || 0).toFixed(2)}`.padEnd(10) +
          new Date(vector.timestamp).toLocaleDateString()
        );
      });

      console.log('‚îÄ'.repeat(80));
      
      // Ask user which record to keep
      const readline = require('readline').createInterface({
        input: process.stdin,
        output: process.stdout
      });

      const question = (prompt) => new Promise((resolve) => {
        readline.question(prompt, resolve);
      });

      let recordToKeep = null;
      
      while (!recordToKeep) {
        const answer = await question(`\nü§î Which record should we keep? (1-${stats.totalCount}, or 'first' for most recent): `);
        
        if (answer.toLowerCase() === 'first') {
          recordToKeep = stats.vectors[0];
          console.log(`‚úÖ Keeping first record: ${recordToKeep.id}`);
          break;
        }
        
        const index = parseInt(answer) - 1;
        if (index >= 0 && index < stats.totalCount) {
          recordToKeep = stats.vectors[index];
          console.log(`‚úÖ Keeping record ${index + 1}: ${recordToKeep.id}`);
          break;
        }
        
        console.log('‚ùå Invalid selection. Please try again.');
      }

      const confirmAnswer = await question(`\n‚ö†Ô∏è  CONFIRM: Delete ${stats.totalCount - 1} records, keeping only "${recordToKeep.id}"? (yes/no): `);
      
      if (confirmAnswer.toLowerCase() !== 'yes') {
        console.log('‚ùå Operation cancelled');
        readline.close();
        return { success: false, message: 'Cancelled by user' };
      }

      readline.close();

      // Delete all records except the one we're keeping
      console.log('\nüóëÔ∏è  Deleting records...');
      
      const recordsToDelete = stats.vectors.filter(v => v.id !== recordToKeep.id);
      
      for (const record of recordsToDelete) {
        await this.table.delete(`id = '${record.id}'`);
        console.log(`   ‚úÖ Deleted: ${record.id}`);
      }

      console.log(`\n‚úÖ Successfully deleted ${recordsToDelete.length} records`);
      console.log(`üìù Kept 1 record: ${recordToKeep.id}`);

      // Verify the wipe
      const finalStats = await this.getStats();
      console.log(`\nüìä Final storage count: ${finalStats.totalCount} records`);

      return {
        success: true,
        message: `Wiped ${recordsToDelete.length} records, kept 1`,
        keptRecord: recordToKeep.id,
        deletedCount: recordsToDelete.length
      };

    } catch (error) {
      console.error('‚ùå Failed to wipe storage:', error.message);
      throw error;
    }
  }

  async close() {
    try {
      if (this.db) {
        this.db = null;
        this.table = null;
        console.log('üîå Disconnected from storage');
      }
    } catch (error) {
      console.error('‚ùå Error closing storage:', error.message);
    }
  }
}

// Main execution
async function main() {
  console.log('üßπ AGENTIC MEMORY STORAGE WIPER');
  console.log('‚ïê'.repeat(80));
  console.log('‚ö†Ô∏è  WARNING: This will delete all but one record from storage!');
  console.log('‚ïê'.repeat(80));
  
  const wiper = new StorageWiper();
  
  try {
    const initialized = await wiper.initialize();
    if (!initialized) {
      console.log('‚ùå Could not initialize storage connection');
      process.exit(1);
    }

    const result = await wiper.wipeAllButOne();
    
    if (result.success) {
      console.log('\n‚úÖ Storage wipe completed successfully');
      console.log(`üìä Result: ${result.message}`);
    } else {
      console.log('\n‚ùå Storage wipe failed');
      console.log(`üìä Result: ${result.message}`);
    }

  } catch (error) {
    console.error('\n‚ùå FATAL ERROR:', error.message);
    process.exit(1);
  } finally {
    await wiper.close();
  }
}

// Handle graceful shutdown
process.on('SIGINT', async () => {
  console.log('\n\nüõë Received interrupt signal');
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('\n\nüõë Received termination signal');
  process.exit(0);
});

// Run the script
if (require.main === module) {
  main().catch(error => {
    console.error('‚ùå Unhandled error:', error);
    process.exit(1);
  });
}

module.exports = StorageWiper;